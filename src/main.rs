use chrono;
use crossbeam::channel::unbounded;
use regex::Regex;
use reqwest::blocking::get;
use std::collections::HashMap;
// use std::fmt::Result; // Removed to avoid conflict with std::result::Result
use std::fs::File;
use std::io::{BufRead, BufReader, Read, Write};
use std::process::Command;
use std::str::FromStr;
use std::thread;

// Constants
const URLS: [&str; 4] = [
    "https://cdn.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
    "https://fastly.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
    "https://testingcf.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
    "https://gcore.jsdelivr.net/gh/ittuann/GitHub-IP-hosts@main/hosts",
];

const HOST_FILE_PATH: &str = "c:/windows/system32/drivers/etc/hosts";
const TEMP_FILE_PATH: &str = "temp_hosts.txt";
const TEMP_HOSTS_FILE_PATH: &str = "temp_hosts";
const MAX_PING_TIME: u32 = std::u32::MAX;

// File operations
fn download_hosts_file() -> Result<(), Box<dyn std::error::Error>> {
    for &url in &URLS {
        println!("Trying to download from: {}", url);
        if let Ok(response) = get(url) {
            if response.status().is_success() {
                File::create(TEMP_FILE_PATH)?.write_all(response.text()?.as_bytes())?;
                println!("Successfully downloaded from: {}", url);
                return Ok(());
            }
        } else {
            println!("Failed to download from: {}", url);
        }
    }
    Err("All download attempts failed".into())
}

fn parse_hosts_file() -> Result<HashMap<String, Vec<String>>, Box<dyn std::error::Error>> {
    let reader = BufReader::new(File::open(TEMP_FILE_PATH)?);
    let mut hosts_map = HashMap::new();

    for line in reader
        .lines()
        .filter_map(Result::ok)
        .map(|line| line.trim().to_string())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
    {
        if let Some((ip, domain)) = line.split_once(' ') {
            hosts_map
                .entry(domain.to_string())
                .or_insert_with(Vec::new)
                .push(ip.to_string());
        }
    }

    Ok(hosts_map)
}

fn write_hosts_file(
    domain_ips: &HashMap<String, (String, u32)>,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut file = File::create(TEMP_HOSTS_FILE_PATH)?;

    writeln!(file, "# Generated by updatehosts4r")?;
    writeln!(
        file,
        "# Date: {}",
        chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
    )?;
    writeln!(file)?;

    for (domain, (ip, time)) in domain_ips {
        writeln!(file, "{:<15}    {:<55}    # ping: {}ms", ip, domain, time)?;
    }

    Ok(())
}

// Network operations
fn ping_ip(ip: &str) -> Result<u32, Box<dyn std::error::Error>> {
    let output = Command::new("ping")
        .args(["-n", "4", "-w", "1000", ip])
        .output()?;

    let output_str = String::from_utf8_lossy(&output.stdout);

    if !output.status.success() {
        return Ok(MAX_PING_TIME);
    }

    let mut total_time = 0;
    let mut count = 0;
    let re = Regex::new(r"=(\d+)ms").unwrap();

    for line in output_str.lines() {
        if line.contains(ip) && line.contains("TTL=") {
            if let Some(caps) = re.captures(line) {
                if let Some(time_str) = caps.get(1) {
                    if let Ok(time) = u32::from_str(time_str.as_str()) {
                        total_time += time;
                        count += 1;
                    }
                }
            }
        }
    }

    if count == 0 {
        Ok(MAX_PING_TIME)
    } else {
        Ok(total_time / count)
    }
}

fn select_fastest_ips(hosts_map: &HashMap<String, Vec<String>>) -> HashMap<String, (String, u32)> {
    let mut result = HashMap::new();
    let (tx, rx) = unbounded();

    for (domain, ips) in hosts_map {
        let domain = domain.clone();
        let ips = ips.clone();
        let tx = tx.clone();

        thread::spawn(move || {
            let mut min_time = MAX_PING_TIME;
            let mut fastest_ip = None;

            for ip in ips {
                match ping_ip(&ip) {
                    Ok(time) => {
                        let time_str = if time == MAX_PING_TIME {
                            "timeout".to_string()
                        } else {
                            format!("{} ms", time)
                        };
                        let domain_str = format!(" {} [{}]", domain.trim_ascii(), ip);
                        println!("{:<65} ==> {}", domain_str, time_str);
                        if time < min_time {
                            min_time = time;
                            fastest_ip = Some(ip);
                        }
                    }
                    Err(e) => {
                        println!("{} {} ==> {}", domain, ip, e);
                        continue;
                    }
                }
            }

            if let Some(ip) = fastest_ip {
                tx.send((domain, (ip, min_time))).unwrap();
            }
        });
    }

    drop(tx);

    while let Ok((domain, ip_time)) = rx.recv() {
        result.insert(domain, ip_time);
    }

    result
}

// System operations
fn copy_and_flush_dns() -> Result<(), Box<dyn std::error::Error>> {
    let mut hosts_content = Vec::new();
    File::open(TEMP_HOSTS_FILE_PATH)?.read_to_end(&mut hosts_content)?;

    let mut system_hosts = File::create(HOST_FILE_PATH)?;
    system_hosts.write_all(&hosts_content)?;

    let output = Command::new("ipconfig").arg("/flushdns").output()?;

    if !output.status.success() {
        return Err("Failed to flush DNS cache".into());
    }

    Ok(())
}

// Main workflow
fn run_select_fastest_ips() -> Result<(), Box<dyn std::error::Error>> {
    let hosts_map = parse_hosts_file()?;
    if hosts_map.is_empty() {
        return Err("Hosts map is empty".into());
    }

    println!("Total domains: {}", hosts_map.len());

    let fastest_ips = select_fastest_ips(&hosts_map);

    println!("\nFastest IPs selected for {} domains", fastest_ips.len());
    println!("\nResults (domain -> ip -> ping time):");
    for (domain, (ip, time)) in &fastest_ips {
        println!("{:>40} -> {:<15} -> {}ms", domain, ip, time);
    }

    println!("\nWriting results to hosts file...");
    write_hosts_file(&fastest_ips)?;
    println!("Done!");

    Ok(())
}

// Main function
fn main() -> std::result::Result<(), Box<dyn std::error::Error>> {
    println!("Starting updatehosts4r...");
    download_hosts_file()?;

    println!("Hosts file downloaded successfully.");
    println!("Parsing hosts file...");
    run_select_fastest_ips()?;
    println!("Hosts file parsed successfully.");

    copy_and_flush_dns()?;
    println!("Hosts file updated and DNS cache flushed.");

    // Clean up temporary files
    std::fs::remove_file(TEMP_FILE_PATH)?;
    print!("Temporary file {} removed.\n", TEMP_FILE_PATH);

    std::fs::remove_file(TEMP_HOSTS_FILE_PATH)?;
    println!("Temporary files cleaned up.");

    // show press any key to exit
    println!("Press any key to exit...");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;

    Ok(()) // Explicitly return Ok(())
}

// Tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ping_ip_success() {
        let result = ping_ip("39.156.70.46");
        assert!(result.is_ok());
        let avg_time = result.unwrap();
        println!("Acutal Ping time: {}ms {}", avg_time, MAX_PING_TIME);
        assert!(
            avg_time < MAX_PING_TIME,
            "Ping time should be less than MAX_PING_TIME"
        );
        assert!(avg_time > 0, "Ping time should be greater than 0");
    }

    #[test]
    fn test_ping_ip_invalid() {
        let result = ping_ip("256.256.256.256");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), MAX_PING_TIME);
    }

    #[test]
    fn test_ping_ip_unreachable() {
        let result = ping_ip("192.168.255.255");
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), MAX_PING_TIME);
    }
}
